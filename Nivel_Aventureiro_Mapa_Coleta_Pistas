#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h> // Para a fun√ß√£o tolower ou toupper (opcional, mas bom para BST de strings)

// --- I. DEFINI√á√ÉO DA ESTRUTURA DO MAPA (√ÅRVORE BIN√ÅRIA) ---

/**
 * @brief Estrutura que representa um c√¥modo (N√≥) no mapa da mans√£o.
 */
typedef struct Sala {
    char nome[50];          // Nome do c√¥modo
    char pista[100];        // Pista associada √† sala (pode ser vazia)
    struct Sala* esquerda;  // Caminho esquerdo
    struct Sala* direita;   // Caminho direito
} Sala;


// --- II. DEFINI√á√ÉO DA ESTRUTURA DE PISTAS (√ÅRVORE BST) ---

/**
 * @brief Estrutura que representa um n√≥ na √Årvore Bin√°ria de Busca (BST) de Pistas.
 */
typedef struct PistaNode {
    char conteudo[100];         // Conte√∫do da pista
    struct PistaNode* esquerda; // Menor que o pai
    struct PistaNode* direita;  // Maior que o pai
} PistaNode;


// --- III. VARI√ÅVEL GLOBAL DA BST DE PISTAS ---
PistaNode* raizPistas = NULL;


// =========================================================================
//                  IV. FUN√á√ïES DO MAPA (√ÅRVORE BIN√ÅRIA)
// =========================================================================

/**
 * @brief Cria e aloca dinamicamente um novo c√¥modo (N√≥) no mapa.
 * @param nomeSala O nome do c√¥modo.
 * @param pistaConteudo O conte√∫do da pista (use "" se n√£o houver pista).
 * @return O ponteiro para a nova sala criada.
 */
Sala* criarSala(const char* nomeSala, const char* pistaConteudo) {
    Sala* novaSala = (Sala*)malloc(sizeof(Sala));

    if (novaSala == NULL) {
        printf("Erro: Falha na alocacao de memoria para a sala %s.\n", nomeSala);
        exit(1);
    }

    strncpy(novaSala->nome, nomeSala, 49);
    novaSala->nome[49] = '\0';
    
    strncpy(novaSala->pista, pistaConteudo, 99);
    novaSala->pista[99] = '\0';

    novaSala->esquerda = NULL;
    novaSala->direita = NULL;

    return novaSala;
}

/**
 * @brief Libera recursivamente a mem√≥ria alocada para o mapa (√Årvore Bin√°ria).
 */
void liberarMapa(Sala* raiz) {
    if (raiz != NULL) {
        liberarMapa(raiz->esquerda);
        liberarMapa(raiz->direita);
        free(raiz);
    }
}

// =========================================================================
//                  V. FUN√á√ïES DA BST DE PISTAS
// =========================================================================

/**
 * @brief Cria e aloca dinamicamente um novo n√≥ de pista.
 */
PistaNode* criarPistaNode(const char* conteudo) {
    PistaNode* novoNode = (PistaNode*)malloc(sizeof(PistaNode));
    if (novoNode == NULL) {
        printf("Erro: Falha na alocacao de memoria para a pista.\n");
        exit(1);
    }
    strncpy(novoNode->conteudo, conteudo, 99);
    novoNode->conteudo[99] = '\0';
    novoNode->esquerda = NULL;
    novoNode->direita = NULL;
    return novoNode;
}

/**
 * @brief Insere recursivamente uma nova pista na BST, mantendo a ordem alfab√©tica.
 * @param raiz O n√≥ raiz da BST.
 * @param novaPista O conte√∫do da pista a ser inserida.
 * @return O novo n√≥ raiz da BST.
 */
PistaNode* inserirPista(PistaNode* raiz, const char* novaPista) {
    // Caso base: Se a sub-arvore estiver vazia, cria o novo n√≥ aqui
    if (raiz == NULL) {
        return criarPistaNode(novaPista);
    }

    // Compara strings alfabeticamente
    // strcmp retorna: < 0 se o primeiro for menor; > 0 se o primeiro for maior
    if (strcmp(novaPista, raiz->conteudo) < 0) {
        // Nova pista √© alfabeticamente MENOR: vai para a esquerda
        raiz->esquerda = inserirPista(raiz->esquerda, novaPista);
    } else if (strcmp(novaPista, raiz->conteudo) > 0) {
        // Nova pista √© alfabeticamente MAIOR: vai para a direita
        raiz->direita = inserirPista(raiz->direita, novaPista);
    }
    // Se for igual, a pista j√° existe (n√£o faz nada, ignoramos duplicatas)

    return raiz;
}

/**
 * @brief Percorre a BST em Ordem Sim√©trica (In-Ordem) para exibir as pistas ordenadas.
 * @param raiz O n√≥ raiz da sub-√°rvore de pistas.
 */
void exibirPistas(PistaNode* raiz) {
    if (raiz != NULL) {
        // 1. Visita a sub-√°rvore esquerda (menores)
        exibirPistas(raiz->esquerda);
        
        // 2. Processa o n√≥ atual (imprime a pista)
        printf(" -> %s\n", raiz->conteudo);
        
        // 3. Visita a sub-√°rvore direita (maiores)
        exibirPistas(raiz->direita);
    }
}

/**
 * @brief Libera recursivamente a mem√≥ria alocada para a BST de pistas.
 */
void liberarPistas(PistaNode* raiz) {
    if (raiz != NULL) {
        liberarPistas(raiz->esquerda);
        liberarPistas(raiz->direita);
        free(raiz);
    }
}


// =========================================================================
//                  VI. FUN√á√ÉO DE EXPLORA√á√ÉO INTERATIVA
// =========================================================================

/**
 * @brief Permite a navega√ß√£o interativa e coleta de pistas no mapa.
 * @param hallRaiz O ponteiro para o Hall de entrada (raiz do mapa).
 */
void explorarSalasComPistas(Sala* hallRaiz) {
    Sala* salaAtual = hallRaiz;
    char escolha;
    int pistasColetadas = 0;
    
    printf("\n==== INICIO DA INVESTIGACAO COM COLETA DE PISTAS ====\n");
    printf("Voce esta no HALL DE ENTRADA.\n");
    
    // Loop principal de navegacao
    while (salaAtual != NULL) {
        printf("\n------------------------------------------------\n");
        printf("Voce esta em: %s\n", salaAtual->nome);
        
        // Coleta de Pista
        if (strcmp(salaAtual->pista, "") != 0) {
            printf("üîç PISTA ENCONTRADA: '%s'\n", salaAtual->pista);
            
            // Adiciona a pista √† BST e marca a sala como 'limpa'
            raizPistas = inserirPista(raizPistas, salaAtual->pista);
            pistasColetadas++;
            
            // Para evitar a coleta da mesma pista mais de uma vez
            strcpy(salaAtual->pista, ""); 
            printf("‚úÖ Pista adicionada a sua Arvore de Indicios. Total: %d\n", pistasColetadas);
        } else {
            printf("Sem novas pistas nesta sala.\n");
        }
        
        // --- Op√ß√µes de Navega√ß√£o ---
        
        // Verifica se ainda h√° caminhos dispon√≠veis
        bool temCaminho = (salaAtual->esquerda != NULL || salaAtual->direita != NULL);

        if (!temCaminho) {
            printf("\n--- CAMINHO FINAL --- \n");
            printf("Nao ha mais caminhos a explorar a partir daqui. Por favor, digite 's' para sair.\n");
        }
        
        printf("Opcoes: ");
        if (salaAtual->esquerda != NULL) {
            printf("[e] Esquerda -> %s ", salaAtual->esquerda->nome);
        }
        if (salaAtual->direita != NULL) {
            printf("[d] Direita -> %s ", salaAtual->direita->nome);
        }
        printf("[s] Sair\n");
        
        printf("Escolha: ");
        if (scanf(" %c", &escolha) != 1) {
             // Lida com entrada inv√°lida
             while(getchar() != '\n'); 
             escolha = ' ';
        }
        
        Sala* proximaSala = NULL;

        switch (tolower(escolha)) {
            case 'e':
                proximaSala = salaAtual->esquerda;
                if (proximaSala == NULL) {
                    printf("‚ùå Caminho da Esquerda Bloqueado ou Inexistente!\n");
                }
                break;
            case 'd':
                proximaSala = salaAtual->direita;
                if (proximaSala == NULL) {
                    printf("‚ùå Caminho da Direita Bloqueado ou Inexistente!\n");
                }
                break;
            case 's':
                printf("\n--- INVESTIGACAO ENCERRADA PELO DETETIVE ---\n");
                return; // Encerra a fun√ß√£o e retorna para main
            default:
                printf("‚ö†Ô∏è Opcao invalida. Digite 'e', 'd' ou 's'.\n");
                continue; 
        }
        
        // Avan√ßa para a pr√≥xima sala se o caminho for v√°lido
        if (proximaSala != NULL) {
            salaAtual = proximaSala;
        }
    }
}

// =========================================================================
//                  VII. FUN√á√ÉO PRINCIPAL (MONTAGEM E EXECU√á√ÉO)
// =========================================================================

int main() {
    // 1. Montagem do Mapa da Mans√£o (√Årvore Bin√°ria)
    
    // N√≠vel 0: Raiz (Hall)
    Sala* hall = criarSala("Hall de Entrada", "Pegadas de barro na entrada");

    // N√≠vel 1
    Sala* salaEstar = criarSala("Sala de Estar", "Vidro quebrado perto da lareira");
    Sala* cozinha = criarSala("Cozinha", ""); // Sem pista
    hall->esquerda = salaEstar;
    hall->direita = cozinha;

    // N√≠vel 2
    Sala* escritorio = criarSala("Escritorio", "Carta com ameaca anonima");
    Sala* biblioteca = criarSala("Biblioteca", ""); // Sem pista
    Sala* lavanderia = criarSala("Lavanderia", "Mancha de oleo em um pano");
    
    salaEstar->esquerda = escritorio;
    salaEstar->direita = biblioteca;
    cozinha->esquerda = lavanderia;
    cozinha->direita = NULL; 

    // N√≠vel 3: Folhas ou caminhos que continuam
    Sala* quartoPrincipal = criarSala("Quarto Principal", "Relogio parado as 3:15");
    Sala* jardim = criarSala("Jardim", "Rastros de pneus no gramado");
    
    escritorio->esquerda = quartoPrincipal;
    escritorio->direita = NULL;
    biblioteca->esquerda = jardim; // Exemplo de BST
    biblioteca->direita = NULL;
    
    lavanderia->esquerda = NULL; 
    lavanderia->direita = NULL;
    quartoPrincipal->esquerda = NULL;
    quartoPrincipal->direita = NULL;
    jardim->esquerda = NULL;
    jardim->direita = NULL;


    printf("Mapa da Mansao montado e pistas escondidas.\n");
    
    // 2. Inicia a Explora√ß√£o e Coleta de Pistas
    explorarSalasComPistas(hall);
    
    // 3. Exibe o Relat√≥rio Final (Pistas Coletadas em Ordem Alfab√©tica)
    printf("\n================================================\n");
    printf("     RELATORIO FINAL: INDICIOS COLETADOS (BST)\n");
    printf("================================================\n");

    if (raizPistas == NULL) {
        printf("Nenhuma pista foi coletada durante a investigacao.\n");
    } else {
        exibirPistas(raizPistas); // O In-Ordem garante a ordem alfab√©tica
    }
    printf("================================================\n");
    
    // 4. Limpeza de Mem√≥ria (Boa pr√°tica)
    liberarMapa(hall);
    liberarPistas(raizPistas);
    
    return 0;
}
